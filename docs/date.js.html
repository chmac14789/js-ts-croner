

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      Croner - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <link id="google-font" href="https://fonts.googleapis.com/css?family=Roboto+Mono|Cutive+Mono|Roboto:300,400,700" rel="stylesheet">
  <link type="text/css" rel="stylesheet" href="styles/highlight-themes/current.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <link type="text/css" rel="stylesheet" href="styles/collapsible.css">
  <link type="text/css" rel="stylesheet" href="styles/style-switcher.css">
  <link type="text/css" rel="stylesheet" href="styles/selectric.css">
  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
  <script src="https://embed.runkit.com"></script>
  <style id="style-switcher-styles">
    nav {
        background: #282c34;
    }
    .hljs {
        background: #1d2027;
    }
    .nav-container > ul > li.active a {
        color: #dcdcdc;
    }
    .nav-container > ul > li.active a:hover {
        color: #f78200;
    }
    .nav-container > ul > li.active ul {
        border-color: #f78200;
    }
    h4.name {
        color: #f78200;
    }
    .params > div > code, .params > div > em {
        color: #f78200;
    }
    a, a:active {
        color: #f78200;
    }
    .hljs-doctag, .hljs-keyword, .hljs-formula {
        color: #f78200;
    }
    nav ul a:hover, nav ul a:active {
        color: #f78200;
    }
  </style>
</head>

<body>
  <header class="header-fixed">
      <h1>
        <a href="index.html" title="modernTemplate.title">
            
                <img alt="Croner" src="https://cdn.jsdelivr.net/gh/hexagon/croner@master/croner.png" />
            
            Croner
        </a>
      </h1>
      <div class="center-header">
          <ul>
            
          </ul>
      </div>
      <div class="right-header">
           
                <a href="https://github.com/hexagon/croner" title="View it on Github" style="">
                    <i class="fab fa-github-alt"></i>
                </a>
           
                <a href="https://www.npmjs.com/package/croner" title="View it on NPM" style="font-size: 19px">
                    <i class="fas fa-exclamation-triangle"></i>
                </a>
           
      </div>
  </header>

  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <nav>
    <div id="menu-container" class="scrollbar-inner">
        <div class="nav-container">
            <h3>Classes</h3><ul><li id="Cron-nav"><a href="Cron.html">Cron</a><ul class='methods'><li data-type="method" id="Cron-msToNext-nav"><a href="Cron.html#msToNext">msToNext</a></li><li data-type="method" id="Cron-next-nav"><a href="Cron.html#next">next</a></li><li data-type="method" id="Cron-pause-nav"><a href="Cron.html#pause">pause</a></li><li data-type="method" id="Cron-previous-nav"><a href="Cron.html#previous">previous</a></li><li data-type="method" id="Cron-resume-nav"><a href="Cron.html#resume">resume</a></li><li data-type="method" id="Cron-running-nav"><a href="Cron.html#running">running</a></li><li data-type="method" id="Cron-schedule-nav"><a href="Cron.html#schedule">schedule</a></li><li data-type="method" id="Cron-stop-nav"><a href="Cron.html#stop">stop</a></li></ul></li><li id="CronDate-nav"><a href="CronDate.html">CronDate</a><ul class='methods'><li data-type="method" id="CronDate-getDate-nav"><a href="CronDate.html#getDate">getDate</a></li><li data-type="method" id="CronDate-getTime-nav"><a href="CronDate.html#getTime">getTime</a></li><li data-type="method" id="CronDate-increment-nav"><a href="CronDate.html#increment">increment</a></li></ul></li><li id="CronPattern-nav"><a href="CronPattern.html">CronPattern</a></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#convertTZ">convertTZ</a></li><li><a href="global.html#maxDelay">maxDelay</a></li></ul>
        </div>
    </div>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        date.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>import convertTZ from "./timezone.js";

/**
 * Converts date to CronDate
 * @constructor
 * 
 * @param {CronDate|date|string} [date] - Input date, if using string representation ISO 8001 (2015-11-24T19:40:00) local timezone is expected
 * @param {string} [timezone] - String representation of target timezone in Europe/Stockholm format.
 */
function CronDate (date, timezone) {	

	this.timezone = timezone;
	
	if (date &amp;&amp; date instanceof Date) {
		this.fromDate(date);
	} else if (date === void 0) {
		this.fromDate(new Date());
	} else if (date &amp;&amp; typeof date === "string") {
		this.fromString(date);
	} else if (date instanceof CronDate) {
		this.fromCronDate(date);
	} else {
		throw new TypeError("CronDate: Invalid type (" + typeof date + ") passed as parameter to CronDate constructor");
	}
}

/**
 * Sets internals using a Date 
 * @private
 * 
 * @param {Date} date - Input date
 * @param {boolean} fromLocal - Target already in local time 
 */
CronDate.prototype.fromDate = function (date, fromLocal) {
	
	if (this.timezone &amp;&amp; !fromLocal) {
		date = convertTZ(date, this.timezone);
	}

	this.milliseconds = date.getMilliseconds();
	this.seconds = date.getSeconds();
	this.minutes = date.getMinutes();
	this.hours = date.getHours();
	this.days = date.getDate();
	this.months  = date.getMonth();
	this.years = date.getFullYear();
};

/**
 * Sets internals by deep copying another CronDate
 * @private
 * 
 * @param {CronDate} date - Input date
 */
CronDate.prototype.fromCronDate = function (date) {
	this.timezone = date.timezone;
	this.milliseconds = date.milliseconds;
	this.seconds = date.seconds;
	this.minutes = date.minutes;
	this.hours = date.hours;
	this.days = date.days;
	this.months  = date.months;
	this.years = date.years;
};

/**
 * Reset internal parameters (seconds, minutes, hours) that may have exceeded their ranges
 * @private
 * 
 * @param {Date} date - Input date
 */
CronDate.prototype.apply = function () {
	let newDate = new Date(this.years, this.months, this.days, this.hours, this.minutes, this.seconds, this.milliseconds);
	
	this.milliseconds = newDate.getMilliseconds();
	this.seconds = newDate.getSeconds();
	this.minutes = newDate.getMinutes();
	this.hours = newDate.getHours();
	this.days = newDate.getDate();
	this.months  = newDate.getMonth();
	this.years = newDate.getFullYear();
};

/**
 * Sets internals by parsing a string
 * @private
 * 
 * @param {Date} date - Input date
 */
CronDate.prototype.fromString = function (str) {

	let parsedDate = this.parseISOLocal(str);

	// Throw if we did get an invalid date
	if( isNaN(parsedDate) ) {
		throw new TypeError("CronDate: Provided string value for CronDate could not be parsed as date.");
	}
	
	this.fromDate(parsedDate, true);
};

/**
 * Increment to next run time
 * @public
 * 
 * @param {string} pattern - The pattern used to increment current state
 * @param {boolean} [rerun=false] - If this is an internal incremental run
 * @return {CronDate|null} - Returns itself for chaining, or null if increment wasnt possible
 */
CronDate.prototype.increment = function (pattern, rerun) {

	if (!rerun) {
		this.seconds += 1;
	}

	this.milliseconds = 0;

	let self = this,
		origTime = self.getTime(),

		
		/**
		 * Find next
		 * 
		 * @param {string} target
		 * @param {string} pattern
		 * @param {string} offset
		 * @param {string} override
		 * 
		 * @returns {boolean}
		 * 
		 */
		findNext = function (target, pattern, offset, override) {
			
			let startPos = (override === void 0) ? self[target] + offset : 0 + offset;

			for( let i = startPos; i &lt; pattern[target].length; i++ ) {

				if( pattern[target][i] ) {
					self[target] = i-offset;
					return true;
				}
			}
			return false;

		},
		
		resetPrevious = function () {
			// Now when we have gone to next minute, we have to set seconds to the first match
			// Now we are at 00:01:05 following the same example.
			// 
			// This goes all the way back to seconds, hence the reverse loop.
			while(doing >= 0) {

				// Ok, reset current member(e.g. seconds) to first match in pattern, using 
				// the same method as aerlier
				// 
				// Note the fourth parameter, stating that we should start matching the pattern
				// from zero, instead of current time.
				findNext(toDo[doing][0], pattern, toDo[doing][2], 0);

				// Go back up, days -> hours -> minutes -> seconds
				doing--;
			}
		};

	// Array of work to be done, consisting of subarrays described below:
	// [
	//   First item is which member to process,
	//   Second item is which member to increment if we didn't find a mathch in current item,
	//   Third item is an offset. if months is handled 0-11 in js date object, and we get 1-12
	//   from pattern. Offset should be -1
	// ]
	let toDo = [
			["seconds", "minutes", 0],
			["minutes", "hours", 0],
			["hours", "days", 0],
			["days", "months", -1],
			["months", "years", 0]
		],
		doing = 0;

	// Ok, we're working our way trough the toDo array, top to bottom
	// If we reach 5, work is done
	while(doing &lt; 5) {

		// findNext sets the current member to next match in pattern
		// If time is 00:00:01 and pattern says *:*:05, seconds will
		// be set to 5

		// If pattern didn't provide a match, increment next vanlue (e.g. minues)
		if(!findNext(toDo[doing][0], pattern, toDo[doing][2])) {
			this[toDo[doing][1]]++;
			resetPrevious();
		}

		// Bail out if an impossible pattern is used
		if (this.years >= 4000) {
			return null;
		}

		// Gp down, seconds -> minutes -> hours -> days -> months -> year
		doing++;
	}

	// This is a special case for weekday, as the user isn't able to combine date/month patterns 
	// with weekday patterns, it's just to increment days until we get a match.
	while (!pattern.daysOfWeek[this.getDate(true).getDay()]) {
		this.days += 1;
		doing = 2;
		resetPrevious();
	}

	// If anything changed, recreate this CronDate and run again without incrementing
	if (origTime != self.getTime()) {
		self.apply();
		return self.increment(pattern, true);
	} else {
		return this;
	}

};

/**
 * Convert current state back to a javascript Date()
 * @public
 * 
 * @param {boolean} internal - If this is an internal call
 * @returns {Date}
 */
CronDate.prototype.getDate = function (internal) {
	let targetDate = new Date(this.years, this.months, this.days, this.hours, this.minutes, this.seconds, this.milliseconds);
	if (internal || !this.timezone) {
		return targetDate;
	} else {
		let offset = convertTZ(targetDate, this.timezone).getTime()-targetDate.getTime();
		return new Date(targetDate.getTime()-offset);
	}
};

/**
 * Convert current state back to a javascript Date() and return UTC milliseconds
 * @public
 * 
 * @param {boolean} internal - If this is an internal call
 * @returns {Date}
 */
CronDate.prototype.getTime = function (internal) {
	return this.getDate(internal).getTime();
};

/**
 * Takes a iso 8001 local date time string and creates a Date object
 * @private
 * 
 * @param {string} s - an ISO 8001 format date and time string
 *                      with all components, e.g. 2015-11-24T19:40:00
 * @returns {Date|number} - Date instance from parsing the string. May be NaN.
 */
CronDate.prototype.parseISOLocal = function (s) {
	let b = s.split(/\D/);

	// Check for completeness
	if (b.length &lt; 6) {
		return NaN;
	}

	let
		year = parseInt(b[0], 10),
		month = parseInt(b[1], 10),
		day = parseInt(b[2], 10),
		hour = parseInt(b[3], 10),
		minute = parseInt(b[4], 10),
		second = parseInt(b[5], 10);

	// Check parts for numeric
	if( isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hour) || isNaN(minute) || isNaN(second) ) {
		return NaN;
	} else {
		return new Date(year, month-1, day, hour, minute, second);
	}
};

export { CronDate };</code></pre>
  </article>
</section>

    



  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a>
  </footer>

    

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>
  <script src="scripts/scrollbar.js"></script>
  <script src="scripts/collapsible.js"></script>
  <script src="scripts/jquery.selectric.min.js"></script>
  <script src="scripts/clipboard.min.js"></script>

  <script>hljs.initHighlightingOnLoad();</script>

  
  <script>
      $(function () {
          $('#menu-container').scrollbar();

          
      });
    </script>
</body>
</html>
